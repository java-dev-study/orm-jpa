## JPA 소개

**1. SQL을 직접 다룰 때 발생하는 문제점**

1. 반복, 반복 그리고 반복
- SQL을 작성하고 JDBC API를 사용하는 비슷한 일 반복
- DB는 객체 구조와는 다른 데이터 중심 구조 → 개발자가 중간에서 SQL과 JDBC API를 사용해서 변환 작업

`문제`
> - 객체를 DB에 CRUD하려면 너무 많은 SQL과 JDBC API를 코드로 작성해야 함
> - 테이블마다 비슷한 일을 반복

2. SQL에 의존적인 개발
- A 객체가 B 객체를 사용할 수 있을지 없을지는 전적으로 사용하는 SQL에 달려 있음
- 데이터 접근 계층을 사용해서 SQL을 숨겨도 어쩔 수 없이 DAO를 열어서 어떤 SQL이 실행되는지 확인해야 한다는 것이 큰 문제
- `엔티티` : 비즈니스 요구사항을 모델링한 객체
- 강한 의존관계는 필드 하나가 추가되면 DAO의 CRUD 코드와 SQL 대부분을 변경해야 함

`문제점 요약`
> - 진정한 의미의 계층 분할이 어려움
> - 엔티티를 신뢰할 수 없음
> - SQL에 의존적인 개발을 피하기 어려움

3. JPA와 문제 해결
- `JPA`를 사용하면 객체를 DB에 저장하고 관리할 때, `JPA`가 제공하는 API 사용\
→ 개발자가 직접 SQL을 작성하지 않음

`JPA가 제공하는 CRUD API`
`매핑정보 : 어떤 객체를 어떤 테이블에 관리할지 정의한 정보`

- 저장 기능 : 객체와 매핑정보를 보고 적절한 `INSERT SQL` 생성
```java
jpa.persist(member);  //객체를 DB에 저장
```

- 조회 기능 : 객체와 매핑정보를 보고 적절한 `SELECT SQL`을 생성
```java
String memberId = "helloId";
Member member = jpa.find(Member.class, memberId); //객체 하나를 DB에서 조회
```

- 수정 기능 : 별도의 수정 메소드를 제공하지는 않으나 객체를 조회해서 값을 변경만 하면 트랜잭션을 커밋할 때 DB에 적절한 `UPDATE SQL` 전달
```java
Member member = jpa.find(Member.class, memberId);
member.setName("이름변경"); //수정
```

- 연관된 객체 조회 : 연관된 객체를 사용하는 시점에 적절할 `SELECT SQL` 실행
```java
Member member = jpa.find(Member.class, memberId);
Team team = member.getTeam(); //연관 객체 조회
```

---

**2. 패러다임의 불일치**

1. 상속
- 객체는 `상속`이라는 기능을 가지고 있지만 테이블은 없음
- `슈퍼타입 서브타입 관계`를 사용하면 객체 상속과 가장 유사한 형태로 테이블 설계는 가능

`JPA와 상속`
- `JPA`는 상속과 관련된 패러다임의 불일치 문제를 해결
- 자바 컬렉션에 액체를 저장하듯이 `JPA`에게 객체를 저장하면 됨

2. 연관관계
- `객체`는 **침조**를 사용해서 다른 객체와 연관관계를 가지고 **참조에 접근해서 연관된 객체를 조회**
- `테이블`은 **외래 키**를 사용해서 다른 테이블과 연관관계를 가지고 **조인을 사용해서 연관된 테이블을 조회**
- `객체`는 참조가 있는 방향으로만 조회 가능

`객체를 테이블에 맞추어 모델링`
- 객체를 테이블에 맞추어 모델링할 경우 객체를 테이블에 저장하거나 조회할 때는 편리
- 좋은 객체 모델링은 기대하기 어렵고 결국 객체지향의 특징을 잃어버림

`객체지향 모델링`
- 외래 키 값을 그대로 보관하는 것이 아니라 연관된 객체의 참조를 보관
- 객체를 테이블에 저장하거나 조회하기 어려움
- `객체 모델`은 외래 키가 필요없고 참조만 있으면 되며, `테이블`은 참조는 필요없고 외래 키만 있으면 됨\
→ 개발자가 중간에서 변환 필요

`JPA와 연관관계`
- `JPA`는 연관관계와 관련된 패러다임의 불일치 문제를 해결
- 개발자는 객체 간 관계를 설정하고 A 객체를 저장
- `JPA`는 B의 참조를 외래 키로 변환해서 `INSERT SQL`을 DB에 전달

3. 객체 그래프 탐색
- 객체는 객체 그래프를 마음껏 탐색할 수 있어야 함
- `SQL`을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해짐\
→ 객체지향 개발에서 큰 제약\
비즈니스 로직에 따라 사용하는 `객체 그래프`가 다른데 언제 끊어질지 모르는 `객체 그래프`를 함부로 탐색할 순 없음

`JPA와 객체 그래프 탐색`
- `JPA`를 ㅅ용하면 객체 그래프를 마음껏 탐색 가능
- `JPA`는 연관된 객체를 사용하는 시점에 적절한 `SELECT SQL` 실행\
→ 연관된 객체를 신뢰하고 마음껏 조회 가능
- 이 기능은 실체 객체를 사용하는 시점까지 DB 조회를 미룬다고 하여 `지연 로딩`이라 함

4. 비교
- `DB`는 기본 키의 값으로 각 row 구분
- `객체`는 동일성 비교과 동등성 비교
> - `동일성 비교` : == 비교, 객체 인스턴스의 주소 값 비교
> - `동등성 비교` : equals() 메소드, 객체 내부의 값을 비교

- DB의 같은 row를 조회했지만 객체의 동일성 비교에는 실패할 수 있음
- 객체를 컬렉션에 보관했다면 동일성 비교에 성공했을 것

`JPA와 비교`
- `JPA`는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장
- 동일성 비교에 성공

---

**3. JPA란 무엇인가?**

`JPA`
> - Java Persistence API
> - 자바 진영의 ORM 기술 표준
> - 애플리케이션과 JDBC 사이에서 동작

`ORM`
> - Object-Relational Mapping
> - 객체와 관계형 DB를 매핑
> - 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결
> - `하이버네이트 프레임워크`를 가장 많이 사용

1. JPA 소개
- `하이버네이트`라는 오픈소스 ORM 프레임워크 등장\
→ EJB의 ORM 기술과 비교해서 가볍고 실용적인 데다 기술 성숙도도 높음
- EJB 3.0에서 하이버네이트를 기반으로 새로운 자바 ORM 기술 표준을 만든 것이 `JPA`
- `JPA` : 자바 ORM 기술에 대한 API 표준 명세 (인터페이스를 모아둔 것)
- `JPA`를 사용하려면 `JPA`를 구현한 ORM 프레임워크를 선택해야 함
- 특정 구현 기술에 대한 의존도를 줄일 수 있고 다른 구현 기술로 손쉽게 이동 가능
- 일반적이고 공통적인 기능의 모음

2. 왜 JPA를 사용해야 하는가?

`생산성`
> - 지루하고 반복적인 코드와 CRUD용 SQL을 개발자가 직접 작성하지 않아도 됨
> - DDL 문을 자동으로 생성해주는 기능 존재
`유지보수`
> - 필드를 추가하거나 삭제해도 수정해야 할 코드가 줄어듦
> - 개발자가 작성해야 했던 SQL과 JDBC API 코드를 `JPA`가 대신 처리해주므로 유지보수해야 하는 코드 수가 줄어듦
> - 패러다임 불일치 문제를 해결해 주므로 객체지향 언어가 가진 장점들을 활용하여 유연하고 유지보수하기 좋은 도메인 모델 설계 가능

`패러다임의 불일치 해결`
> - 상속, 연관관계, 객체 그래프 탐색, 비교하기와 같은 패러다임 불일치 문제 해결

`성능`
> - 다양한 성능 최적화 기회를 제공
> - 하이버네이트는 SQL 힌트를 넣을 수 있는 기능도 제공

`데이터 접근 추상화와 벤더 독립성`
> - 추상화된 데이터 접근 계층을 제공해서 애플리케이션이 특정 DB 기술에 종속되지 않도록 함

`표준`
> - 자바 진영의 ORM 기술 표준
