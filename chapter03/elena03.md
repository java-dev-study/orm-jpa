## 영속성 관리


`엔티티 매니저`
> - 엔티티를 저장하고, 수정하고, 삭제하고, 조회하는 등 엔티티와 관련된 모든 일을 처리
> - 엔티티를 관리하는 관리자
> - 개발자 입장에서 엔티티를 저장하는 가상의 DB

**1. 엔티티 매니저 팩토리와 엔티티 매니저**
- DB를 하나만 사용하는 애플리케이션은 일반적으로 EntityManagerFactory를 하나만 생성
```java
// 엔티티 매니저 팩토리 생성 코드, 비용이 많이 듦
EntityManagerFactory emf = Persistence.createEntityManagerFacotry("jpabook");
```
- 이후 필요할 때마다 엔티티 매니저 팩토리에서 엔티티 매니저 생성
```java
//공장에서 엔티티 매니저 생성, 비용이 거의 안 듦
EntityManager em = emf.createEntityManager();
```
- `엔티티 매니저 팩토리`는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유 가능
- `엔티티 매니저`는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안 됨
- `엔티티 매니저`는 DB 연결이 꼭 필요한 시점까지 커넥션을 얻지 않음

---

**2. 영속성 컨텍스트란?**
- persistence context
- 엔티티를 영구 저장하는 환경
- 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 `영속성 컨텍스트`에 엔티티를 보관하고 관리
```java
em.persist(member);
```
- persist() : 엔티티 매니저를 사용해서 A 엔티티를` 영속성 컨텍스트`에 저장
- `영속성 컨텍스트`는 엔티티 매니저를 생성할 때 하나 만들어짐

---

**3. 엔티티의 생명주기**
- 엔티티에는 `4가지 상태`가 존재

`비영속`
> - new/transient
> - 영속성 컨텍스트와 전혀 관계가 없는 상태
> - 엔티티 객체를 생성했고, 순수한 객체 상태이며 아직 저장하지 않은 상태

`영속`
> - managed
> - 영속성 컨텍스트에 저장된 상태
> - 영속성 컨텍스트가 관리하는 엔티티
> - `em.find()`나 JPQL을 사용해서 조회한 엔티티도 `영속 상태`

`준영속`
> - detached
> - 영속성 컨텍스트에 저장되었다가 분리된 상태
> - 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않는 것
> - `em.detach()` : 특정 엔티티를 `준영속 상태`로 만들 때 호출
> - `em.close()`나 `em.clear()`를 호출해 영속성 컨텍스트를 닫거나 초기화해도 영속 상태의 엔티티는 `준영속 상태`

`삭제`
> - removed
> - 삭제된 상태
> - 엔티티를 영속성 컨텍스트와 DB에서 삭제
> - `em.remove()`

---

**4. 영속성 컨텍스트의 특징**

`영속성 컨텍스트와 식별자 값`
> - 영속성 컨텍스트는 엔티티를 `식별자 값`으로 구분
> - 영속 상태는 `식별자 값`이 반드시 있어야 함

`영속성 컨텍스트와 데이터베이스 저장`
> - 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 DB에 반영 : `플러시(flush)`

`영속성 컨텍스트가 엔티티를 관리할 때 장점`
> - 1차 캐시
> - 동일성 보장
> - 트랜잭션을 지원하는 쓰기 지연
> - 변경 감지
> - 지연 로딩


1. 엔티티 조회
- 영속성 컨텍스트는 내부에 캐시를 가지고 있음 : `1차 캐시`
- 영속 상태의 엔티티는 모두 `1차 캐시`에 저장
- `1차 캐시`의 키는 식별자 값 → `식별자 값`은 DB 기본 키와 매핑
- 영속성 컨텍스트에 데이터를 저장하고 조회하는 모든 기준은 `DB 기본 키 값`
- `find()` 메소드 : 첫 번째 파라미터는 엔티티 클래스의 타입, 두 번째 파라미터는 조회할 엔티티의 식별자 값\
→ `em.find()`를 호출하면 먼저 `1차 캐시`에서 엔티티를 찾고 없으면 DB에서 조회

2. 엔티티 등록
- 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 DB에 엔티티를 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 모아둠
- 트랜잭션을 커밋할 때 모아둔 쿼리를 DB에 보냄 : `트랜잭션을 지원하는 쓰기 지연(transaction write-behind)`
- 영속성 컨텍스트의 변경 내용을 DB에 동기화한 후 실제 DB 트랜잭션을 커밋

`트랜잭션을 지원하는 쓰기 지연이 가능한 이유`
- A, B, C 모두 트랜잭션을 커밋하면 함께 저장되고 롤백하면 함께 저장되지 않음
- 등록 쿼리를 그때 그때 DB에전달해도 트랜잭션을 커밋하지 않으면 아무 소용 없음
- 어떻게든 커밋 직전에만 DB에 SQL을 전달하면 됨

3. 엔티티 수정

`SQL 수정 쿼리의 문제점`
- 수정 쿼리가 많아짐
- 비즈니스 로직을 분석하기 위해 SQL을 계속 확인해야 함
- 직접적이든 간접적이든 비즈니스 로직이 SQL에 의존하게 됨

`변경 감지`
- `JPA`로 엔티티를 수정할 때는 단순히 엔티티를 조회해서 데이터만 변경
- `변경 감지(dirty checking)` : 엔티티의 변경사항을 DB에 자동으로 반영하는 기능
- `스냅샷` : 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해둠\
→ 플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾음
- `변경 감지`는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용

4. 엔티티 삭제
- 삭제 대상 엔티티 조회
- `em.remove()`에 삭제 대항 엔티티를 넘겨주면 엔티티를 삭제
- 즉시 삭제하는 것은 아니고 엔티티 등록과 비슷하게 삭제 쿼리를 쓰기 지연 SQL 저장소에 등록
- 삭제된 엔티티는 재사용하지 말고 GB의 대상이 되도록 두는 것이 좋음

---

**5. 플러시**

`플러시(flush())`
- 영속성 컨텍스트의 변경 내용을 DB에 반영
- 영속성 컨텍스트를 플러시하는 방법
> 1. `em.flush()`를 직접 호출
> - 엔티티 매니저의 flush() 메소드 직접 호출하여 영속성 컨텍스트를 강제로 플러시
> - 거의 사용 X
> 2. 트랜잭션 커밋 시 플러스가 자동 호출
> 3. JPQL 쿼리 실행 시 플러시가 자동 호출

1. 플러시 모드 옵션
- 엔티티 매니저에 플러시 모드를 직접 지정하려면 `javax.persistence.FlushModeType` 사용
> - FlushModeType.AUTO : 커밋이나 쿼리를 실행할 때 플러시(기본값)
> - FlushModeType.COMMIT : 커밋할 때만 플러시

---

**6. 준영속**
- 영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 것
- `준영속 상태`의 엔티티는 영속성 컨텍스느가 제공하는 기능을 사용할 수 없음

1. 엔티티를 준영속 상태로 전환: detach()
- 특정 엔티티를 준영속 상태로 만듦
- 이 메소드를 호출하는 순간 1차 캐시부터 쓰기 지연 SQL 저장소까지 해당 엔티티를 관리하기 위한 모든 정보가 제거됨

2. 영속성 컨텍스트 초기화: clear()
- 영속성 컨텍스트를 초기화해서 해당 영속성 컨텍스트의 모든 엔티티를 준영속 상태로 만듦
- 변경 감지도 동작하지 않음

3. 영속성 컨텍스트 종료: close()
- 영속성 컨텍스트를 종료하면 해당 영속성 컨텍스트가 관리하던 영속 상태의 엔티티가 모두 준영속 상태가 됨

4. 준영속 상태의 특징
- 거의 비영속 상태에 가까움
- 식별자 값을 가지고 있음
- 지연 로딩을 할 수 없음

5. 병합: merge()
- 준영속 상태의 엔티티를 다시 영속 상태로 변경
- 준영속 상태의 엔티티를 받아서 그 정보로 **새로운 영속 상태의 엔티티를 반환**
- 준영속 병합, 비영속 병합
- 병합은 준영속, 비영속을 신경 쓰지 않음
- 식별자 값으로 엔티티를 조회할 수 있으면 불러서 병합하서 조회할 수 없으면 새로 생성해서 병함
- 병합 : save or update 기능 수행
