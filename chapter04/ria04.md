## Chapter04 엔티티 매핑
### 4.1 @Entity
- @Entity 어노테이션이 붙은 클래스는 JPA가 관리하는 클래스임
    - 기본 생성자 필수
    - final 클래스, enum, interface, inner 클래스에는 사용 불가
    - 저장할 필드에 final 사용 금지
### 4.2 @Table
- @Table 어노테이션은 엔티티와 매핑할 테이블을 지정함 
### 4.3 다양한 매핑 사용
- @Enumerated
- @Temporal
- @Lob
### 4.4 데이터베이스 스키마 자동 생성
- JPA는 데이터베이스 스키마 자동 생성 기능을 지원함
    - 속성을 추가하면 애플리케이션 실행 시점에 데이터베이스 테이블 자동 생성 가능 (운영에서 사용할만큼 완벽하진 않음)
### 4.5 DDL 생성 기능
- 속성값을 사용하여 DDL에 제약조건을 추가할 수 있지만, DDL을 자동으로 생성할 때만 사용되고 JPA 실행 로직에는 영향을 주지 않음
### 4.6 기본 키 매핑
- JPA가 제공하는 데이터베이스 기본키 생성 전략
    1. 직접 할당 : 기본키를 애플리케이션에서 직접 할당
    2. 자동 생성 : 대리키 사용 방식
        - IDENTITY : 기본키 생성을 데이터베이스에 위임
        - SEQUENCY : 데이터베이스 시퀀스를 사용해서 기본키 할당
        - TABLE : 키 생성 테이블 사용
#### 4.6.1 기본키 직접 할당 전략
- @Id로 매핑
- 기본키 직접 할당 전략은 `em.persist()`로 엔티티를 저장하기 전에 애플리케이션에서 기본키를 직접 할당하는 방법임
#### 4.6.2 IDENTITY 전략
- 기본키 생성을 데이터베이스에 위임
- MySQL의 `AUTO_INCREMENT`
- 데이터베이스에 값을 저장하고 나서야 기본키 값을 구할 수 있을 때 사용
- `em.persist()`를 호출해서 엔티티를 저장한 직후에 할당된 식별자 출력 가능
    - 저장 시점에 데이터베이스가 생성한 값을 JPA가 조회함
#### 4.6.3 SEQUENCE 전략
- `em.persist()`를 호출할 때 데이터베이스 시퀀스를 사용해서 식별자를 조회함
- 조회한 식별자를 엔티티에 할당한 후 엔티티를 영속성 컨텍스트에 저장
- 트랜잭션 커밋 후 플러시가 발생하면 엔티티를 데이터베이스에 저장함
#### 4.6.4 TABLE 전략
- 키 생성 전용 테이블을 만들면 모든 데이터베이스에 적용 가능
#### 4.6.7 AUTO 전략
- 선택한 데이터베이스 방언에 따라 IDENTITY, SEQUENCE, TABLE 전략 중 하나를 자동으로 선택함
    - 데이터베이스를 변경해도 코드를 수정할 필요가 없음

### 4.7 필드와 컬럼 매핑 : 레퍼런스