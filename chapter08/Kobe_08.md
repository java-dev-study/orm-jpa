# 8. 프록시와 연관관계 관리

### 프록시와 즉시로딩, 지연로딩

- 객체는 객체 그래프로 연관된 객체들을 탐색
객체는 데이터베이스에 저장되어 있어 연관된 객체를 아음껏 탐색하는것은 어렵다.
- 즉시로딩, 지연로딩
- 영속성 전이와 고아 객체 
JPA는 연관된 객체를 함꼐 저장하거나 함께 삭제할 수 있는 영속성 전이와 고아 객체 제거라는 기능을 제공

### 프록시

엔티티를 조회할 때 연관된 엔티티들이 항상 사용되는 것은 아니다.

회원 엔티티를 조회한다면 팀 엔티티는 조회될수도, 안 될수도 있다.

이럴때 회원 엔티티(사용되지 않는 엔티티) 까지 DB에서 함께 조회하는 것은 효율적이지 않다. JPA는 이러한 문제를 해결하기 위해서 실제 해당 엔티니가 사용 될 때 까지 DB 조회를 기다리는데 이것을 지연로딩이라고 한다. 
지연 로딩 기능을 사용하기 위해서는 실제 엔티티 객체가 아닌 가짜 객체가 필요한데, 이 객체를 프록시 객체라고 한다.

### 프록시 기초

JPA에서는 식별자로 엔티티 하나를 조회할 때는 EntityManager.find()를 사용한다.

이 메소드는 영속성 컨텍스트에 엔티티가 없으면 DB를 조회한다.

하지만 엔티티를 실제로 사용하지 않으면 불필요한 작업을 하는것이기 때문에, 

EntityManager.getReference()메소드를 사용한다.

해당 메소드를 사용하면 JPA는 데이터베이스를 조회하지 않고 엔티티 객체도 생성하지 않는다. 대신에 데이터베이스 접근을 위한 프록시 객체를 반환한다.

### 프록시 특징

프록시 객체는 실제 클래스를 상속 받아서 사용하기 때문에 실제 클래스와 겉 모양이 같다. 따라서 사용하는 사용자 입장에서는 이것이 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다.

프록시 객체는 실제 객체의 참조(target)을 보관한다. 메소드를 사용한다고 해도, 타겟을 통해 메소드를 호출한다.

- 프록시 객체 초기화

프록시 객체는 member.getName()처럼 실제 사용될 떄 데이터베이스를 조회해서 실제 엔티티 객체를 생성하는데, 이것을 프록시 객체의 초기화라고 한다. 

**프록시 특징**

- 프록시 객체는 처음 사용할 때 한 번만 초기화된다.
- 프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다.
프록시 객체가 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근할 수 있다.
- 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크 시에 주의해서 사용해야한다.
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 데이터베이스를 조회할 필요가 없어 em.getRefernce()를 호출해도 프록시가 아닌 실제 엔티티를 반환한다.
- 초기화는 영속성 컨텍스트의 도움을 받아야 가능하다. 따라서 영속성 컨텍스트의 도움을 방을 수 없는 중영속 상태의 프록시를 초기화하면 문제가 발생한다.

**프록시와 식별자**

- 엔티티를 프록시로 조회할 때 식별자 값을 파라미터로 전달하는데 프록시 객체는 이 식별자 값을 보관한다.
- 프록시 객체는 식별자 값을 자기오 있어 id를 조회해도 프록시를 초기화하지 않는다. [AccessType.Property](http://AccessType.Property) 인경우
- 엔티티 접근 방식을 AccessType.FIELD로 설정하면 JPA는 id만 조회하는지 다른 필드까지 활용하는지 몰라서 프록시 객체를 초기화한다.
- 연관 관계를 설정할 때 식별자 값만 사용하기 떄문에 프록시를 사용하면 DB 접근 횟수를 줄일 수 있다.

**즉시 로딩, 지연 로딩**

- 프록시 객체는 주로 연관된 엔티티를 지연 로딩할 때 사용한다.

EX) 회원 엔티티를 조회할때 팀을 같이 가져오는 게 좋을까? 좋지 않을까.

- 즉시로딩 : 회원 엔티티와 팀 엔티티를 즉시 모두 가져온다. - @ManyToOne(fetch = FetchType.EAGER)
- 지연로딩 : 연관된 엔티티를 실제 사용할 때 조회한다. - @ManyToOne(fetch = FetchType.LAZY)

**즉시로딩** 

- 외부 조인으로 쿼리를 뽑음 하지만 @JoinColumn nullable =false를 설정하여 내부 조인 사용 가능

**지연로딩**

- @ManyToOne(fetch = FetchType.LAZY)
- 프록시 객체를 이용하여 엔티티를 조회한다. 조회 대상이 영속성 컨텍스트에 이미 있으면 프록시 객체가 아닌실제 객체를 사용한다.

JPA는 홀로 있는 엔티티는 기본 즉시 로딩, 컬렉션이면 지연 로딩을 사용한다. - 김영한은 모든 연관관계에 지연 로딩을 추천했다.

- 컬렉션 하나 이상을 즉시로딩하지 않기
- 컬렉션 즉시 로딩은 항상 외부 조인을 사용한다. → 데이터 누락 발생 원인
- 컬렉션인 경우 - @ManyToOne, @OneToOne: 즉시 로딩
- @OneToMany, @ManyToMany : 지연 로딩

**영속성 전이 : Cascade**

- 특정 엔티티를 영속 성태로 만들 때 연관된 엔티티도 함께 영속 상태로 만드는 기능을 영속성 전이 기능이라고 한다. JPA CASCADE
- 영속성 전이를 사용하면 부모 엔티티를 저장할 떄 자식 엔티티도 함께 저장할 수 있다.

**고아 객체**

JPA는 부모 엔티티와 연관 관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공한다. → 고아 객체 제거

- 부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제된다.

**영속성 전이 + 고아 객체**

- CascadeType.All(모두 적용) + orphanRemoval = TRUE 고아 객체 사용
- 부모 엔티티를 통해 자식 엔티티의 생명 주기를 관리
- 자식을 저장하기 위해 부모에만 등록 필요(Cascade)
- 자식을 삭제하려면 부모에서 제거하면 된다.(orphanRemoval)
- 즉 관리 쉬움