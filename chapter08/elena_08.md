## 프록시와 연관관계 관리

**1. 프록시**
- 엔티티 조회 시 연관된 엔티티들이 항상 사용되는 것은 아님
- `지연 로딩` : 엔티티가 실제 사용될 때까지 DB 조회를 지연하는 방법
- `지연 로딩` 기능을 사용하려면 `프록시 객체`가 필요
- `프록시 객체` : 실제 엔티티 객체 대신 DB 조회를 지연할 수 있는 가짜 객체

　
1. 프록시 기초
- 식별자로 엔티티 조회 시 : `EntityManager.find()`\
→ 영속성 컨텍스트에 엔티티가 없으면 DB를 조회
- 엔티티를 실제 사용하는 시점까지 DB 조회를 미루고 싶을 경우 `EntityManager.getReference()` 메소드 사용\
→ DB 접근을 위임한 `프록시 객체` 반환
- `프록시 객체`는 실제 객체에 대한 참조를 보관
- `프록시 객체 초기화` : 실제 사용될 때 DB를 조회해서 실제 엔티티 객체 생성 

`프록시 특징`
- 처음 사용할 때 한 번만 초기화됨
- 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능
- 원본 엔티티를 상속받은 객체이므로 타입 체크 시 주의
- 영속성 컨텍스트에 찾는 엔티티가 있을 경우 프록시가 아닌 실제 엔티티 반환
- 준영속 상태의 프록시 초기화 시 오류 발행 (`org.hibernate.LazyInitializationException`)

2. 프록시와 식별자
- `프록시 객체`는 파라미터로 전달하는 식별자 값을 보관
- 프록시를 사용하면 DB 접근 횟수 줄이기 가능

3. 프록시 확인
- 프록시 인스턴스 초기화 여부 확인 : `PersistenceUnitUtil.isLoaded(Object entity)`

---

**2. 즉시 로딩과 지연 로딩**
1. 즉시 로딩
- 엔티티를 조회할 때 연관된 엔티티도 함께 조회
- `@ManyToOne (fetch = FetchType.EAGER)`
- JPA 구현체는 즉시 로딩을 최적화하기 위해 가능하면 조인 쿼리를 사용

2. 지연 로딩
- 연관된 엔티티를 실제 사용할 때 조회
- `@ManyToOne (fetch = FetchType.LAZY)`
- 실제 데이터가 필요한 순간이 되어서야 DB를 조회해서 프록시 객체 초기화

---

**3. 지연 로딩 활용**
1. 프록시와 컬렉션 래퍼
- `컬렉션 래퍼` : 엔티티를 영속 상태로 만들 때 엔티티에 컬렉션ㅇ 있으면 컬렉션을 추가하고 관리할 목적으로 원본 컬렉션을 하이버네이트가 제공하는 내장 컬렉션으로 변경

2. JPA 기본 패치 전략
- 연관된 엔티티가 하나면 `즉시 로딩`, 컬렉션이면 `지연 로딩`
- 추천하는 방법은 모든 연관관계에 `지연 로딩` 사용

3. 컬렉션에 FetchType.EAGER 사용 시 주의점
- 컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않음
- 컬렉션 즉시시 로딩은 항상 외부 조인(OUTER JOIN)을 사용

---

**4. 영속성 전이: CASCADE**
- JPA는 `CASADE` 옵션으로 영속성 전이를 제공
- `영속성 전이`를 사용하면 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장 가능

　
1. 영속성 전이: 저장
- 부모를 영속화할 때 연관된 자식들도 함께 영속화 : `cascade = CascadeType.PERSIST)`
- `영속성 전이`는 연관관계를 매핑하는 것과는 관련 없음
- 엔티티를 영속화할 때 연관된 엔티티도 같이 영속화하는 편리함을 제공할 뿐

2. 영속성 전이: 삭제
- 부모와 자식 엔티티를 모두 제거하려면 각각의 엔티티를 하나씩 제거해야 함
- `CascadeType.REMOVE`로 설정 시 부모 엔티티만 삭제하면 연관된 자식 엔티티도 함께 삭제됨
- 삭제 순서 : 외래 키 제약조건을 고려하여 자식 → 부모

---

**5. 고아 객체**
- `고아 객체(ORPHAN) 제거` : 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능
- 이 기능을 사용하여 부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제
- `orpahnRemoval = true`
- 참조하는 곳이 하나일 때만 사용 → `@OneToOne`, `@OneToMany`에만 사용 가능

---

**6. 영속성 전이 + 고아 객체, 생명주기**
- `CascadeType.ALL` + `orpahnRemoval = true`를 동시에 활성화할 경우\
→ 부모 엔티티를 통해서 자식의 생명주기 관리 가능
