## 값 타입

- JPA 데이터 타입 : `엔티티 타입`과 `값 타입`
- `엔티티 타입` : `@Entity`로 정의하는 객체
- `값 타입` : 단순히 값으로 사용하는 자바 기본 타입이나  객체

`값 타입`
- `기본값 타입(basic value type)` : 자바 기본 타입, 래퍼 클래스, String
- `임베디드 타입(embedded type)` : 복합 값 타입
- `컬렉션 값 타입(collection value type)`

　
**1. 기본값 타입**
- 자바 기본 타입 (int, double 등)
- 래퍼 클래스 (Integer 등)
- String

---

**2. 임베디드 타입(복합 값 타입)**
- `임베디드 타입` : 새로운 값 타입을 직접 정의해서 사용
- `@Embeddable` : 값 타입을 정의하는 곳에 표시
- `@Embedded` : 값 타입을 사용하는 곳에 표시
- `컴포지션(composition) 관계` : 임베디드 타입을 포함한 모든 값 타입은 엔티티의 생명주기에 의존하므로 엔티티와 인베디드 타입의 관계를 UML로 표현한 것

　
1. 임베디드 타입과 테이블 매핑
- `임베디드 타입`은 엔티티의 값일 뿐 → 값이 속한 엔티티의 테이블에 매핑

2. 임베디드 타입과 연관관계
- `임베디드 타입`은 값 타입을 포함하거나 엔티티 참조 가능

3. @AttributeOverride: 속성 재정의
- `@AttributeOverride` : 임베디드 타입에 정의한 매핑정보 재정의 (엔티티에 설정)

4. 임베디드 타입과 null
- `임베디드 타입`이 null이면 매핑한 컬럼 값은 모두 null

---

**3. 값 타입과 불변 객체**
1. 값 타입 공유 참조
- 임베디드 타입 같은 `값 타입`을 여러 엔티티에서 공유하면 위험
- `부작용(side effect)` : 뭔가를 수정했는데 전혀 예상치 못한 곳에서 문제가 발생하는 것

2. 값 타입 복사
- `부작용` 방지 방법
- 문제는 `임베디드 타입`처럼 직접 정의한 값 타입은 객체 타입이라는 것
- 자바는 객체에 값을 대입하면 항상 참조값을 전달
- 객체를 대입할 때마다 인스턴스를 복사해서 대입하면 공유 참조를 피할 수는 있음\
→ 그러나 복사하지 않고 원본의 참조 값을 직접 넘기는 것을 막을 방법이 없음

3. 불변 객체
- 부작용이 일어나면 값 타입이라 할 수 없음
- 객체를 불변하게 만들면 값을 수정할 수 없으므로 부작용 원천 차단 가능\
→ 값 타입은 될 수 있으면 `불변 객체(immutable Object)`로 설계
- `불변 객체` : 한 번 만들면 절대 변경할 수 없는 객체

---

**4. 값 타입의 비교**
- `동일성(Identity) 비교` : 인스턴스의 참조 값을 비교, `==` 사용
- `동등성(Equivalence) 비교` : 인스턴스의 값을 비교, `equals()` 사용
- 값 타입의 `euqals()` 메소드 재정의 시에는 보통 모든 필드의 값을 비교하도록 구현

---

**5. 값 타입 컬렉션**
- 값 타입을 하나 이상 저장하려면 컬렉션에 보관하고 `@ElementCollection`, `@CollectionTable` 사용
- 테이블 매핑정보는 `@AttributeOverride`를 사용해서 재정의 가능

　
1. 값 타입 컬렉션 사용
- 값 타입 컬렉션 조회 시에도 페치 전략 선택 가능 : `LAZY`가 기본

2. 값 타입 컬렉션의 제약사항
- 식별자라는 개념이 없음
- 값을 변경해버리면 DB에 저장된 원본 데이터를 찾기 
